# -*- coding: utf-8 -*-
"""TensorReshapeOP1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v4M5584ugL3ZTxr1O1RzsGWT2VeeUq9D
"""

import tensorflow as tf

# Step 1: Create a random tensor of shape (4, 6)
tensor = tf.random.normal(shape=(4, 6))
print("Original Tensor:\n", tensor.numpy())
print()

# Step 2: Find its rank and shape
rank = tf.rank(tensor)
shape = tensor.shape
print("Rank of the tensor:", rank.numpy())
print("Shape of the tensor:", shape)
print()

# Step 3: Reshape it into (2, 3, 4) and transpose it to (3, 2, 4)
reshaped_tensor = tf.reshape(tensor, (2, 3, 4))
transposed_tensor = tf.transpose(reshaped_tensor, perm=[1, 0, 2])
print("Reshaped Tensor (2, 3, 4):\n", reshaped_tensor.numpy())
print("Transposed Tensor (3, 2, 4):\n", transposed_tensor.numpy())
print()

# Step 4: Broadcast a smaller tensor (1, 4) to match the larger tensor and add them
small_tensor = tf.constant([[1.0, 2.0, 3.0, 4.0]])  # Shape (1, 4)
broadcasted_tensor = small_tensor + reshaped_tensor  # Broadcasting happens here
print("Small Tensor:\n", small_tensor.numpy())
print("Broadcasted Tensor (after addition):\n", broadcasted_tensor.numpy())
print()

# Step 5: Explanation of broadcasting
print("Explanation of Broadcasting:")
print("Broadcasting in TensorFlow is a mechanism that allows TensorFlow to perform element-wise operations on tensors of different shapes. It works by expanding the smaller tensor to match the shape of the larger tensor, without actually copying the data. For example, in this case, the smaller tensor of shape (1, 4) is broadcasted to match the shape (2, 3, 4) of the reshaped tensor. The smaller tensor is 'stretched' along the new dimensions to align with the larger tensor for element-wise addition.")

"""# New Section"""